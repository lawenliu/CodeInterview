#LeetCode
Question Distribution
---------------------
```
.
├── 1. Linear List
|   ├── 1.1 Array
|   |   ├── 1.1.1 Remove Duplicates from Sorted Array
|   |   ├── 1.1.2 Remove Duplicates from Sorted Array II
|   |   ├── 1.1.3 Search in Rotated Sorted Array
|   |   ├── 1.1.4 Search in Rotated Sorted Array II
|   |   ├── 1.1.5 Median of Two Sorted Arrays
|   |   ├── 1.1.6 Longest Consecutive Sequence
|   |   ├── 1.1.7 Two Sum
|   |   ├── 1.1.8 3Sum
|   |   ├── 1.1.9 3Sum Closest
|   |   ├── 1.1.10 4Sum
|   |   ├── 1.1.11 Remove Element
|   |   ├── 1.1.12 Next Permutation
|   |   ├── 1.1.13 Permutation Sequence
|   |   ├── 1.1.14 Valid Sudoku
|   |   ├── 1.1.15 Trapping Rain Water
|   |   ├── 1.1.16 Rotate Image
|   |   ├── 1.1.17 Plus One
|   |   ├── 1.1.18 Climbing Stairs
|   |   ├── 1.1.19 Gray Code
|   |   ├── 1.1.20 Set Matrix Zero
|   |   ├── 1.1.21 Gas Station
|   |   ├── 1.1.22 Candy
|   |   ├── 1.1.23 Single Number
|   |   └── 1.1.24 Single Number II
|   |
|   └── 1.2 Link List
|       ├── 1.2.1 Add Two Numbers
|       ├── 1.2.2 Reverse Linked List II
|       ├── 1.2.3 Partition List
|       ├── 1.2.4 Remove Duplicates From Sorted List
|       ├── 1.2.5 Remove Duplicates From Sorted List II
|       ├── 1.2.6 Rotate List
|       ├── 1.2.7 Remove Nth Node From End of List
|       ├── 1.2.8 Swap Nodes in Pairs
|       ├── 1.2.9 Reverse Nodes in k-Group
|       ├── 1.2.10 Copy List with Random Pointer
|       ├── 1.2.11 Linked List Cycle
|       ├── 1.2.12 Linked List Cycle II
|       ├── 1.2.13 Reorder List
|       └── 1.2.14 LRU Cache
|
|
├── 2. Character String
|   ├── 2.1 Valid Palindrome
|   ├── 2.2 Implement strStr()
|   ├── 2.3 String to Integer (atoi)
|   ├── 2.4 Add Binary
|   ├── 2.5 Longest Palindromic Substring
|   ├── 2.6 Regular Expression Matching
|   ├── 2.7 Wildcard Matching
|   ├── 2.8 Longest Common Prefix
|   ├── 2.9 Valid Number
|   ├── 2.10 Integer to Roman
|   ├── 2.11 Roman to Integer
|   ├── 2.12 Count and Say
|   ├── 2.13 Anagrams
|   ├── 2.14 Simplify Path
|   └── 2.15 Length of Last Word
|
|
├── 3. Stack and Queue
|   ├── 3.1 Stack
|   |   ├── 3.1.1 Valid Paraentheses
|   |   ├── 3.1.2 Longest Valid Parantheses
|   |   ├── 3.1.3 Largest Rectangle in Histogram
|   |   └── 3.1.4 Evaluate Reverse Polish Notation
|   |
|   └── 3.2 Queue
|   	└── ... (Used in other sections)
|
|
├── 4. Tree
|   ├── 4.1 Binary Tree Traversal
|   |   ├── 4.1.1 Bianry Tree Preorder Traversal
|   |   ├── 4.1.2 Bianry Tree Inorder Traversal
|   |   ├── 4.1.3 Bianry Tree Postorder Traversal
|   |   ├── 4.1.4 Bianry Tree Level Order Traversal
|   |   ├── 4.1.5 Bianry Tree Level Order Traversal II
|   |   ├── 4.1.6 Binary Tree Zigzag Level Order Traversal
|   |   ├── 4.1.7 Recover Binary Search Tree
|   |   ├── 4.1.8 Same Tree
|   |   ├── 4.1.9 Symmetric Tree
|   |   ├── 4.1.10 Balanced Binary Tree
|   |   ├── 4.1.11 Flatten Binary Tree to Linked List
|   |   └── 4.1.12 Populating Next Right Pointers in Each Node II
|   |
|   ├── 4.2 Binary Tree Construction
|   |   ├── 4.2.1 Construct Binary Tree from Inorder and Postorder Traversal
|   |   └── 4.2.2 Construct Binary Tree from Preorder and Inorder Traversal
|   | 
|   ├── 4.3 Binary Tree Finding
|   |   ├── 4.3.1 Unique Binary Search Trees
|   |   ├── 4.3.2 Unique Binary Search Trees II
|   |   ├── 4.3.3 Validate Binary Search Tree
|   |   ├── 4.3.4 Convert Sorted Array to Binary Search Tree
|   |   └── 4.3.5 Convert Sorted List to Binary Search Tree
|   | 
|   └── 4.4 Binary Tree Recursion
|       ├── 4.4.1 Minimum Depth of Binary Tree
|       ├── 4.4.2 Maximum Depth of Binary Tree
|       ├── 4.4.3 Path Sum
|       ├── 4.4.4 Path Sum II
|       ├── 4.4.5 Binary Tree Maximum Path Sum
|       ├── 4.4.6 Populating Next Right Pointers in Each Node
|       └── 4.4.7 Sum Root to Leaf Numbers
|
|
├── 5. Sort
|   ├── 5.1 Merge Sorted Array
|   ├── 5.2 Merge Two Sorted Lists
|   ├── 5.3 Merge k Sorted Lists
|   ├── 5.4 Insertion Sort List
|   ├── 5.5 Sort List
|   ├── 5.6 First Missing Positive
|   └── 5.7 Sort Colors
|
|
├── 6. Find
|   ├── 6.1 Search for a Range
|   ├── 6.2 Search Insert Position
|   └── 6.3 Search a 2D Matrix
|
|
├── 7. Brute-force
|   ├── 7.1 Subsets
|   ├── 7.2 Subsets II
|   ├── 7.3 Permutations
|   ├── 7.4 Next Permutations II
|   └── 7.5 Letter Combinations of a Phone Number
|
|
├── 8. Breadth First Search
|   ├── 8.1 Word Ladder
|   ├── 8.2 Word Ladder II
|   └── 8.3 Surrounded Regions
|
|
├── 9. Depth First Search
|   ├── 9.1 Palindrome Partitioning
|   ├── 9.2 Unique Paths
|   ├── 9.3 Unique Paths II
|   ├── 9.4 N-Queens
|   ├── 9.5 N-Queens II
|   ├── 9.6 Restore IP Address
|   ├── 9.7 Combination Sum
|   ├── 9.8 Combination Sum II
|   ├── 9.9 Generate Parentheses
|   ├── 9.10 Sudoku Solver
|   └── 9.11 Word Search
|
|
├── 10. Divide and Conquer
|   ├── 10.1 Pow(x, n)
|   └── 10.2 Sqrt(x)
|
|
├── 11. Greedy
|   ├── 11.1 Jump Game
|   ├── 11.2 Jump Game II
|   ├── 11.3 Best Time to Buy and Sell Stock
|   ├── 11.4 Best Time to Buy and Sell Stock II
|   ├── 11.5 Longest Substring without Repeating Characters
|   └── 11.6 Container with Most Water
|
|
├── 12. Dynamic Programming
|   ├── 12.1 Triangle
|   ├── 12.2 Maximum Subarray
|   ├── 12.3 Palindrome Partitioning II
|   ├── 12.4 Maximal Rectangle
|   ├── 12.5 Best Time to Buy and Sell Stock III
|   ├── 12.6 Interleaving String
|   ├── 12.7 Scramble String
|   ├── 12.8 Minimum Path Sum
|   ├── 12.9 Edit Distance
|   ├── 12.10 Decode Ways
|   ├── 12.11 Distinct Subsequences
|   ├── 12.12 Word Break
|   └── 12.13 Word Break II
|
|
├── 13. Graph
|   └── 13.1 Clone Graph
|
|
└── 14. Details Checking
    ├── 14.1 Reverse Integer
    ├── 14.2 Palindrome Number
    ├── 14.3 Insert Interval
    ├── 14.4 Merge Interval
    ├── 14.5 Minimum Window Substring
    ├── 14.6 Multiply Strings
    ├── 14.7 Substring with Concatenation of All Words
    ├── 14.8 Pascal's Triangle
    ├── 14.9 Pascal's Triangle II
    ├── 14.10 Spiral Matrix
    ├── 14.11 Spiral Matrix II
    ├── 14.12 ZigZag Conversion
    ├── 14.13 Divide Two Integers
    ├── 14.14 Text Justification
    └── 14.15 Max Points on a Line
```
    
